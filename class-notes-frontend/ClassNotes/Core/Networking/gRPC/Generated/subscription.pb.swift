// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: subscription.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to validate an Apple receipt
struct ClassNotes_V1_ValidateReceiptRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Base64 encoded receipt data from StoreKit
  var receiptData: String = String()

  /// Transaction ID from StoreKit 2
  var transactionID: String = String()

  /// Product ID purchased
  var productID: String = String()

  /// Original transaction ID for renewals
  var originalTransactionID: String = String()

  /// Purchase date
  var purchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _purchaseDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_purchaseDate = newValue}
  }
  /// Returns true if `purchaseDate` has been explicitly set.
  var hasPurchaseDate: Bool {return self._purchaseDate != nil}
  /// Clears the value of `purchaseDate`. Subsequent reads from it will return its default value.
  mutating func clearPurchaseDate() {self._purchaseDate = nil}

  /// Original purchase date
  var originalPurchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _originalPurchaseDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_originalPurchaseDate = newValue}
  }
  /// Returns true if `originalPurchaseDate` has been explicitly set.
  var hasOriginalPurchaseDate: Bool {return self._originalPurchaseDate != nil}
  /// Clears the value of `originalPurchaseDate`. Subsequent reads from it will return its default value.
  mutating func clearOriginalPurchaseDate() {self._originalPurchaseDate = nil}

  /// Expiration date (for subscriptions)
  var expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expirationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expirationDate = newValue}
  }
  /// Returns true if `expirationDate` has been explicitly set.
  var hasExpirationDate: Bool {return self._expirationDate != nil}
  /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
  mutating func clearExpirationDate() {self._expirationDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _purchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _originalPurchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Response from receipt validation
struct ClassNotes_V1_ValidateReceiptResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the receipt is valid
  var isValid: Bool = false

  /// User's subscription tier (FREE, BASIC, ADVANCED, PRO)
  var tier: String = String()

  /// When the subscription expires
  var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  mutating func clearExpiresAt() {self._expiresAt = nil}

  /// Rejection reason if invalid
  var rejectionReason: String = String()

  /// Whether auto-renewal is enabled
  var autoRenewEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Current subscription status
struct ClassNotes_V1_SubscriptionStatusResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current tier (FREE, BASIC, ADVANCED, PRO)
  var tier: String {
    get {return _storage._tier}
    set {_uniqueStorage()._tier = newValue}
  }

  /// Subscription status (ACTIVE, EXPIRED, CANCELLED, GRACE_PERIOD)
  var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Expiration date
  var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  var hasExpiresAt: Bool {return _storage._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  mutating func clearExpiresAt() {_uniqueStorage()._expiresAt = nil}

  /// Features enabled for this tier
  var enabledFeatures: [String] {
    get {return _storage._enabledFeatures}
    set {_uniqueStorage()._enabledFeatures = newValue}
  }

  /// Current usage summary
  var usage: ClassNotes_V1_UsageSummary {
    get {return _storage._usage ?? ClassNotes_V1_UsageSummary()}
    set {_uniqueStorage()._usage = newValue}
  }
  /// Returns true if `usage` has been explicitly set.
  var hasUsage: Bool {return _storage._usage != nil}
  /// Clears the value of `usage`. Subsequent reads from it will return its default value.
  mutating func clearUsage() {_uniqueStorage()._usage = nil}

  /// Number of registered devices
  var registeredDevices: Int32 {
    get {return _storage._registeredDevices}
    set {_uniqueStorage()._registeredDevices = newValue}
  }

  /// Maximum devices allowed
  var maxDevices: Int32 {
    get {return _storage._maxDevices}
    set {_uniqueStorage()._maxDevices = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Usage statistics
struct ClassNotes_V1_UsageStatisticsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Detailed usage breakdown
  var usage: ClassNotes_V1_UsageSummary {
    get {return _usage ?? ClassNotes_V1_UsageSummary()}
    set {_usage = newValue}
  }
  /// Returns true if `usage` has been explicitly set.
  var hasUsage: Bool {return self._usage != nil}
  /// Clears the value of `usage`. Subsequent reads from it will return its default value.
  mutating func clearUsage() {self._usage = nil}

  /// When usage resets
  var nextResetDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextResetDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextResetDate = newValue}
  }
  /// Returns true if `nextResetDate` has been explicitly set.
  var hasNextResetDate: Bool {return self._nextResetDate != nil}
  /// Clears the value of `nextResetDate`. Subsequent reads from it will return its default value.
  mutating func clearNextResetDate() {self._nextResetDate = nil}

  /// Usage recommendations
  var recommendations: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _usage: ClassNotes_V1_UsageSummary? = nil
  fileprivate var _nextResetDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Usage summary
struct ClassNotes_V1_UsageSummary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lectures used this month
  var lecturesUsed: Int32 = 0

  /// Lectures limit for the tier
  var lecturesLimit: Int32 = 0

  /// Transcript minutes used
  var transcriptMinutesUsed: Int32 = 0

  /// Transcript minutes limit
  var transcriptMinutesLimit: Int32 = 0

  /// OCR pages used
  var ocrPagesUsed: Int32 = 0

  /// OCR pages limit
  var ocrPagesLimit: Int32 = 0

  /// AI tokens used today
  var aiTokensUsedToday: Int32 = 0

  /// Daily AI token limit
  var aiTokensDailyLimit: Int32 = 0

  /// Storage used in bytes
  var storageUsedBytes: Int64 = 0

  /// Storage limit in bytes
  var storageLimitBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Register device request
struct ClassNotes_V1_RegisterDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique device identifier
  var deviceID: String = String()

  /// Device name (e.g., "John's iPhone")
  var deviceName: String = String()

  /// Platform (iOS, iPadOS, macOS)
  var platform: String = String()

  /// OS version
  var osVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Register device response
struct ClassNotes_V1_RegisterDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether registration succeeded
  var success: Bool = false

  /// Error message if failed
  var errorMessage: String = String()

  /// List of all registered devices
  var devices: [ClassNotes_V1_DeviceInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Device information
struct ClassNotes_V1_DeviceInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var deviceName: String = String()

  var platform: String = String()

  var registeredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _registeredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_registeredAt = newValue}
  }
  /// Returns true if `registeredAt` has been explicitly set.
  var hasRegisteredAt: Bool {return self._registeredAt != nil}
  /// Clears the value of `registeredAt`. Subsequent reads from it will return its default value.
  mutating func clearRegisteredAt() {self._registeredAt = nil}

  var lastSeenAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastSeenAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastSeenAt = newValue}
  }
  /// Returns true if `lastSeenAt` has been explicitly set.
  var hasLastSeenAt: Bool {return self._lastSeenAt != nil}
  /// Clears the value of `lastSeenAt`. Subsequent reads from it will return its default value.
  mutating func clearLastSeenAt() {self._lastSeenAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _registeredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastSeenAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "classnotes.v1"

extension ClassNotes_V1_ValidateReceiptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidateReceiptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "receipt_data"),
    2: .standard(proto: "transaction_id"),
    3: .standard(proto: "product_id"),
    4: .standard(proto: "original_transaction_id"),
    5: .standard(proto: "purchase_date"),
    6: .standard(proto: "original_purchase_date"),
    7: .standard(proto: "expiration_date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.receiptData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.productID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.originalTransactionID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._purchaseDate) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._originalPurchaseDate) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._expirationDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.receiptData.isEmpty {
      try visitor.visitSingularStringField(value: self.receiptData, fieldNumber: 1)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 2)
    }
    if !self.productID.isEmpty {
      try visitor.visitSingularStringField(value: self.productID, fieldNumber: 3)
    }
    if !self.originalTransactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.originalTransactionID, fieldNumber: 4)
    }
    try { if let v = self._purchaseDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._originalPurchaseDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._expirationDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClassNotes_V1_ValidateReceiptRequest, rhs: ClassNotes_V1_ValidateReceiptRequest) -> Bool {
    if lhs.receiptData != rhs.receiptData {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.productID != rhs.productID {return false}
    if lhs.originalTransactionID != rhs.originalTransactionID {return false}
    if lhs._purchaseDate != rhs._purchaseDate {return false}
    if lhs._originalPurchaseDate != rhs._originalPurchaseDate {return false}
    if lhs._expirationDate != rhs._expirationDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClassNotes_V1_ValidateReceiptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidateReceiptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_valid"),
    2: .same(proto: "tier"),
    3: .standard(proto: "expires_at"),
    4: .standard(proto: "rejection_reason"),
    5: .standard(proto: "auto_renew_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isValid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tier) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rejectionReason) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.autoRenewEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isValid != false {
      try visitor.visitSingularBoolField(value: self.isValid, fieldNumber: 1)
    }
    if !self.tier.isEmpty {
      try visitor.visitSingularStringField(value: self.tier, fieldNumber: 2)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.rejectionReason.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectionReason, fieldNumber: 4)
    }
    if self.autoRenewEnabled != false {
      try visitor.visitSingularBoolField(value: self.autoRenewEnabled, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClassNotes_V1_ValidateReceiptResponse, rhs: ClassNotes_V1_ValidateReceiptResponse) -> Bool {
    if lhs.isValid != rhs.isValid {return false}
    if lhs.tier != rhs.tier {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.rejectionReason != rhs.rejectionReason {return false}
    if lhs.autoRenewEnabled != rhs.autoRenewEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClassNotes_V1_SubscriptionStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionStatusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tier"),
    2: .same(proto: "status"),
    3: .standard(proto: "expires_at"),
    4: .standard(proto: "enabled_features"),
    5: .same(proto: "usage"),
    6: .standard(proto: "registered_devices"),
    7: .standard(proto: "max_devices"),
  ]

  fileprivate class _StorageClass {
    var _tier: String = String()
    var _status: String = String()
    var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _enabledFeatures: [String] = []
    var _usage: ClassNotes_V1_UsageSummary? = nil
    var _registeredDevices: Int32 = 0
    var _maxDevices: Int32 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tier = source._tier
      _status = source._status
      _expiresAt = source._expiresAt
      _enabledFeatures = source._enabledFeatures
      _usage = source._usage
      _registeredDevices = source._registeredDevices
      _maxDevices = source._maxDevices
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._tier) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._expiresAt) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._enabledFeatures) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._usage) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._registeredDevices) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._maxDevices) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._tier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tier, fieldNumber: 1)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 2)
      }
      try { if let v = _storage._expiresAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._enabledFeatures.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._enabledFeatures, fieldNumber: 4)
      }
      try { if let v = _storage._usage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._registeredDevices != 0 {
        try visitor.visitSingularInt32Field(value: _storage._registeredDevices, fieldNumber: 6)
      }
      if _storage._maxDevices != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxDevices, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClassNotes_V1_SubscriptionStatusResponse, rhs: ClassNotes_V1_SubscriptionStatusResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tier != rhs_storage._tier {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._expiresAt != rhs_storage._expiresAt {return false}
        if _storage._enabledFeatures != rhs_storage._enabledFeatures {return false}
        if _storage._usage != rhs_storage._usage {return false}
        if _storage._registeredDevices != rhs_storage._registeredDevices {return false}
        if _storage._maxDevices != rhs_storage._maxDevices {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClassNotes_V1_UsageStatisticsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UsageStatisticsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "usage"),
    2: .standard(proto: "next_reset_date"),
    3: .same(proto: "recommendations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nextResetDate) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.recommendations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nextResetDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.recommendations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.recommendations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClassNotes_V1_UsageStatisticsResponse, rhs: ClassNotes_V1_UsageStatisticsResponse) -> Bool {
    if lhs._usage != rhs._usage {return false}
    if lhs._nextResetDate != rhs._nextResetDate {return false}
    if lhs.recommendations != rhs.recommendations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClassNotes_V1_UsageSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UsageSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lectures_used"),
    2: .standard(proto: "lectures_limit"),
    3: .standard(proto: "transcript_minutes_used"),
    4: .standard(proto: "transcript_minutes_limit"),
    5: .standard(proto: "ocr_pages_used"),
    6: .standard(proto: "ocr_pages_limit"),
    7: .standard(proto: "ai_tokens_used_today"),
    8: .standard(proto: "ai_tokens_daily_limit"),
    9: .standard(proto: "storage_used_bytes"),
    10: .standard(proto: "storage_limit_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.lecturesUsed) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.lecturesLimit) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.transcriptMinutesUsed) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.transcriptMinutesLimit) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.ocrPagesUsed) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.ocrPagesLimit) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.aiTokensUsedToday) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.aiTokensDailyLimit) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.storageUsedBytes) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.storageLimitBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lecturesUsed != 0 {
      try visitor.visitSingularInt32Field(value: self.lecturesUsed, fieldNumber: 1)
    }
    if self.lecturesLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.lecturesLimit, fieldNumber: 2)
    }
    if self.transcriptMinutesUsed != 0 {
      try visitor.visitSingularInt32Field(value: self.transcriptMinutesUsed, fieldNumber: 3)
    }
    if self.transcriptMinutesLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.transcriptMinutesLimit, fieldNumber: 4)
    }
    if self.ocrPagesUsed != 0 {
      try visitor.visitSingularInt32Field(value: self.ocrPagesUsed, fieldNumber: 5)
    }
    if self.ocrPagesLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.ocrPagesLimit, fieldNumber: 6)
    }
    if self.aiTokensUsedToday != 0 {
      try visitor.visitSingularInt32Field(value: self.aiTokensUsedToday, fieldNumber: 7)
    }
    if self.aiTokensDailyLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.aiTokensDailyLimit, fieldNumber: 8)
    }
    if self.storageUsedBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.storageUsedBytes, fieldNumber: 9)
    }
    if self.storageLimitBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.storageLimitBytes, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClassNotes_V1_UsageSummary, rhs: ClassNotes_V1_UsageSummary) -> Bool {
    if lhs.lecturesUsed != rhs.lecturesUsed {return false}
    if lhs.lecturesLimit != rhs.lecturesLimit {return false}
    if lhs.transcriptMinutesUsed != rhs.transcriptMinutesUsed {return false}
    if lhs.transcriptMinutesLimit != rhs.transcriptMinutesLimit {return false}
    if lhs.ocrPagesUsed != rhs.ocrPagesUsed {return false}
    if lhs.ocrPagesLimit != rhs.ocrPagesLimit {return false}
    if lhs.aiTokensUsedToday != rhs.aiTokensUsedToday {return false}
    if lhs.aiTokensDailyLimit != rhs.aiTokensDailyLimit {return false}
    if lhs.storageUsedBytes != rhs.storageUsedBytes {return false}
    if lhs.storageLimitBytes != rhs.storageLimitBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClassNotes_V1_RegisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "device_name"),
    3: .same(proto: "platform"),
    4: .standard(proto: "os_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClassNotes_V1_RegisterDeviceRequest, rhs: ClassNotes_V1_RegisterDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClassNotes_V1_RegisterDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "error_message"),
    3: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClassNotes_V1_RegisterDeviceResponse, rhs: ClassNotes_V1_RegisterDeviceResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClassNotes_V1_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "device_name"),
    3: .same(proto: "platform"),
    4: .standard(proto: "registered_at"),
    5: .standard(proto: "last_seen_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platform) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._registeredAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastSeenAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 2)
    }
    if !self.platform.isEmpty {
      try visitor.visitSingularStringField(value: self.platform, fieldNumber: 3)
    }
    try { if let v = self._registeredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._lastSeenAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClassNotes_V1_DeviceInfo, rhs: ClassNotes_V1_DeviceInfo) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs._registeredAt != rhs._registeredAt {return false}
    if lhs._lastSeenAt != rhs._lastSeenAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
